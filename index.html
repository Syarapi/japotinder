<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Japontinder</title>
<link href="https://fonts.googleapis.com/css2?family=Yuji+Syuku&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  :root{
    /* Paleta fija para botones/series (NO aleatoria) */
    --yes:#87cefa;          /* AZUL para "Aqu√≠ s√≠" */
    --meh:#8a5adf;          /* MORADO para "Me da igual" */
    --no:#ff7aa3;           /* ROSA para "Pasando" */

    /* Variables de tema aleatorio */
    --ink:#333;
    --bg-light:#fff7fb;
    --bg-mid:#ffe3ef;
    --bg-dark:#d38cb1;
    --card-bg:#ffffffee;
    --accent-1:#FF91C0;
    --accent-2:#FF68A8;
    --petal-rgba: 255,182,193;
  }

  /* ===== Fondo tem√°tico ===== */
  body {
    margin: 0;
    font-family: 'Segoe UI', sans-serif;
    color: var(--ink);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    background: var(--bg-light);
    position: relative;
    overflow-x: hidden;
  }
  body::before, body::after{
  /* anulamos los fondos anteriores */
  content: none !important;
}

/* Cada car√°cter kanji "flotante" */
.kanji-char{
  position: fixed;
  top: -12vh;                 /* empieza un poco por encima */
  left: 0;
  transform: translateX(var(--x, 0)) translateY(0) rotate(var(--r, 0deg));
  font-family: 'Yuji Syuku', serif;
  font-weight: 400;
  line-height: 1;
  pointer-events: none;
  user-select: none;
  z-index: -1;                /* igual que antes: detr√°s del contenido */
  color: rgba(var(--petal-rgba), var(--opa, .25));  /* mismo color que los p√©talos */
  animation: fall-kanji var(--dur, 24s) linear infinite;
  filter: blur(0.2px);
}

/* Dos "capas" con las mismas duraciones que ten√≠as: 24s y 32s */
.kanji-layer-a { --dur: 24s; --opa:.25; }
.kanji-layer-b { --dur: 32s; --opa:.6;  }

/* Animaci√≥n con ligera deriva horizontal y balanceo */
@keyframes fall-kanji{
  0%   { transform: translateX(calc(var(--x, 0) - 10px)) translateY(-12vh) rotate(calc(var(--r, 0deg) - 10deg)); }
  50%  { transform: translateX(calc(var(--x, 0) + 10px)) translateY(55vh)  rotate(calc(var(--r, 0deg) + 10deg)); }
  100% { transform: translateX(calc(var(--x, 0) - 6px))  translateY(135vh) rotate(calc(var(--r, 0deg) + 20deg)); }
}
  h1, h2, h3 { font-family: 'Yuji Syuku', serif; text-align: center; }
  h1 { color: var(--accent-1); text-shadow: 0 2px 0 #fff; margin: 10px 0 6px; }
  h2 { color: var(--accent-2); margin: 6px 0 10px; }
  h3 { color: var(--accent-1); margin: 10px 0; }

  /* Pantallas */
  #start-screen, #mode-screen, #game-screen, #results, #stats-screen {
    display: none;
    flex-direction: column;
    align-items: center;
    width: 100%;
  }
  #start-screen {
    display: flex; justify-content: center; gap: 15px; min-height: 100vh; padding: 16px 10px;
  }

  /* Tarjetas */
#card-container {
  position: relative;
  width: min(92%, 520px);  /* ocupa el 92% pero nunca m√°s de 520px de ancho */
  height: min(70vh, 720px); /* 70% de la altura visible, m√°x 720px */
  display: flex;
  justify-content: center;
  align-items: center;
}

/* Imagen */
.card {
  position: relative;
  width: 100%;
  height: 100%;
  border-radius: 20px;
  overflow: hidden;
  border: 2px solid var(--accent-1);
  box-shadow: 0 10px 25px rgba(0,0,0,0.15);
  will-change: transform;
}

/* Imagen cubre todo */
.card img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
  user-select: none;
  -webkit-user-drag: none;
}

/* Pie en overlay */
.card div {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(255, 255, 255, 0.85); /* blanco semitransparente */
  color: var(--ink);
  font-weight: 600;
  font-size: clamp(14px, 2vw, 16px); /* tama√±o de texto adaptativo */
  padding: 8px 12px;
  text-align: center;
  backdrop-filter: blur(4px); /* da un efecto de vidrio */
}

  /* Botones */
  #buttons {
    margin-top: 10px;
    display: flex;
    gap: 12px;
    z-index: 10;
  }
  .btn {
    padding: 12px 18px;
    font-size: 16px;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: transform .15s ease, box-shadow .15s ease, opacity .2s ease;
    box-shadow: 0 8px 18px rgba(0,0,0,.12);
    color: white;
  }
  #btnNameNext,
.stats-btn {
  background: linear-gradient(180deg, var(--accent-1) 0%, var(--accent-2) 100%);
  color: #fff;
}
  .accept { background: linear-gradient(180deg, var(--yes) 0%, #5fb5ef 100%); }
  .meh    { background: linear-gradient(180deg, var(--meh) 0%, #7343d8 100%); }
  .reject { background: linear-gradient(180deg, var(--no) 0%, #ff5f93 100%); }
  .stats-btn { background: linear-gradient(180deg, var(--accent-1) 0%, var(--accent-2) 100%); color: #fff; }
  .btn:hover { transform: translateY(-1px); box-shadow: 0 10px 20px rgba(0,0,0,.16); }
  .btn:active { transform: translateY(0); opacity:.95; }

  /* Tablas */
  table {
    border-collapse: collapse;
    margin-top: 10px;
    width: 100%;
    background: #fff;
    border-radius: 14px;
    overflow: hidden;
    box-shadow: 0 8px 24px rgba(0,0,0,0.12);
    border: 2px solid var(--accent-1);
    table-layout: auto;
  }
  table th, table td {
    padding: 8px 10px;
    border-bottom: 1px solid #f0e7f8;
    text-align: left;
    word-break: break-word;
  }
  table th {
    background: linear-gradient(180deg, var(--accent-2) 0%, var(--accent-1) 100%);
    color: white; letter-spacing:.3px; font-size: 13px;
  }
  table td { font-size: 13px; }
  table tr:nth-child(even) { background-color: #faf7ff; }
  table tr:hover { background-color: #f4ecff; transition: background .2s ease; }

  .cards-small { line-height: 1.4; }

  /* ===== Start screen: tutorial ===== */
  .tutorial {
    margin-top: 8px;
    max-width: 640px;
    background: var(--card-bg);
    border: 2px solid var(--accent-1);
    border-radius: 14px;
    padding: 10px 12px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.12);
    font-size: 14px;
  }
  .tutorial p { margin: 6px 0; text-align: left; }

  /* ===== Mode split screen ===== */
#mode-screen {
  display: none;
  align-items: stretch;
  padding: 0;
  min-height: 100vh;
  width: 100%;
}

.mode-split {
  display: grid;
  grid-template-columns: 1fr 1fr;
  width: 100%;
  min-height: 100vh;
  position: relative;
}

.half {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  user-select: none;
  padding: 20px 10px;
}

.half::after { /* √°rea clicable completa */
  content: "";
  position: absolute;
  inset: 0;
}

.half .content {
  z-index: 1;
  text-align: center;
  max-width: 520px;
  background: color-mix(in oklab, var(--card-bg) 75%, white 25%);
  border: 2px solid var(--accent-1);
  border-radius: 16px;
  padding: 18px 16px;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
}

.half.left {
  background: transparent; /* transparente */
  border-right: 1px dashed color-mix(in oklab, var(--accent-2) 60%, white);
}

.half.right {
  background: transparent; /* transparente base */
}

.half.right::before {
  content: "";
  position: absolute;
  inset: 0;
  background: color-mix(in srgb, var(--bg-dark) 70%, transparent); /* color del tema */
  z-index: 0; /* detr√°s del contenido */
}

.half h2 { margin: 4px 0 8px; }
.half p { margin: 0; font-size: 14px; opacity: .9; }

.badge {
  display: inline-block;
  margin-top: 8px;
  padding: 4px 8px;
  border-radius: 999px;
  font-weight: 600;
  font-size: 12px;
  color: #fff;
  background: linear-gradient(180deg, var(--accent-1), var(--accent-2));
}


  /* ===== Layout estad√≠sticas ===== */
  #stats-screen {
    min-height: 100vh;
    padding: 6px 10px 10px;
    box-sizing: border-box;
    overflow-y: auto;
  }
  .stats-grid {
    display:grid;
    grid-template-columns: minmax(340px, 1fr) minmax(420px, 1.2fr);
    gap: 12px;
    align-items: start;
  }
  .chart-card, .top-card, .aff-card {
    background: var(--card-bg);
    border: 2px solid var(--accent-1);
    border-radius: 16px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.15);
    padding: 8px;
    display:flex; flex-direction:column;
  }
  .chart-scroll {
    overflow-y: auto;
    max-height: 360px;
    padding-bottom: 6px;
  }
  .chart-container canvas { height: auto !important; max-width: 100%; }

  /* Tablas TOP y Afinidad con L√çMITE (m√°s corto que antes) */
  .top-scroll { overflow-y:auto; max-height: 220px; padding-bottom:6px; }
  .aff-scroll { overflow-y:auto; max-height: 220px; padding-bottom:6px; }

  .affinity-wrap {
    margin-top: 8px;
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
  }
  .aff-card td.cards-small { font-size: 12px; line-height: 1.25; }

  /* ===== Responsive ===== */
  @media (max-width: 980px) {
    body { overflow:auto; }
    .stats-grid { grid-template-columns: 1fr; }
    .affinity-wrap { grid-template-columns: 1fr; }
  }
  @media (max-width: 760px) {
    .stats-grid, .affinity-wrap { grid-template-columns: 1fr !important; gap: 16px; }
    table th, table td { font-size: 13px; padding: 6px 8px; }
    .top-card table td, .aff-card table td { font-size: 12px; }
    .chart-scroll { max-height: 240px; }
    .top-scroll, .aff-scroll { max-height: 180px; }
  }

  /* Color del texto <strong> combinado con el tema */
strong {
  color: rgba(var(--petal-rgba), 1); /* mismo color que kanji/p√©talos */
  font-weight: bold;
}
</style>
</head>
<body>
<div id="kanji-layer" aria-hidden="true"></div>

<!-- Pantalla de inicio -->
<div id="start-screen">
  <div style="text-align:center">
    <h1>Japontinder</h1>
    <div></div>
    <div class="tutorial">
      <h3 style="margin:2px 0 6px;">¬øC√≥mo se juega?</h3>
      <p>Puedes jugar <strong>deslizando</strong> las tarjetas (<em>swipe</em>) o usando los <strong>botones</strong>:</p>
      <ul style="margin:6px 0 0 18px; padding:0;">
        <li><strong>Izquierda</strong> = <span style="color:var(--no); font-weight:600;">No (Pasando)</span></li>
        <li><strong>Derecha</strong> = <span style="color:var(--yes); font-weight:600;">S√≠ (Aqu√≠ s√≠)</span></li>
        <li><strong>Arriba</strong> = <span style="color:var(--meh); font-weight:600;">Me da igual</span></li>
        <p>Si juegas m√°s de una vez, pon <strong>el mismo nombre</strong>, as√≠, si en modo corto se te repite una tarjeta, 
          solo contar√° <strong>la √∫ltima respuesta</strong>.</p>
        <p>Se guarda un resultado por tarjeta, da igual cu√°ntas veces juegues en el modo corto.</p>
      </ul>
    </div>
    <p>¬øQui√©n eres? O no empezamos √≤_√≥</p>
<input type="text" id="username" placeholder="Tu nombre" />
<div style="margin-top:10px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap;">
  <button class="btn btn-theme" id="btnNameNext">Siguiente</button>
  <button class="btn stats-btn" onclick="showStats()">Ver estad√≠sticas</button>
</div>


      
    </div>

  
  </div>
</div>

<!-- Elecci√≥n de modo: pantalla partida -->
<div id="mode-screen">
  <div class="mode-split">
    <div class="half left" id="halfShort">
      <div class="content">
        <h2>Modo corto</h2>
        <p>20 tarjetas <strong>aleatorias</strong>. Puedes usar ‚ÄúMe da igual‚Äù <strong>5 veces</strong>.</p>
        <span class="badge">Toca o haz clic para jugar</span>
      </div>
    </div>
    <div class="half right" id="halfFull">
      <div class="content">
        <h2>Modo completo</h2>
        <p>Todas las tarjetas en orden aleatorio. ‚ÄúMe da igual‚Äù disponible <strong>10 veces</strong>.</p>
        <span class="badge">Toca o haz clic para jugar</span>
      </div>
    </div>
  </div>
</div>

<!-- Juego -->
<div id="game-screen" style="display:none; flex-direction: column; align-items: center;">
  <div id="card-container"></div>
  <div id="buttons">
    <button class="btn reject" onclick="handleDecision(-1)">Pasando</button>
    <button class="btn meh" onclick="handleDecision(0)">Me da igual</button>
    <button class="btn accept" onclick="handleDecision(1)">Aqu√≠ s√≠</button>
  </div>
</div>

<!-- Resultados: SOLO tabla + bot√≥n a estad√≠sticas -->
<div id="results" style="display:none; align-items:center; padding:10px; width:100%; max-width:980px;">
  <h2>Resultados</h2>
  <p id="player-info" style="margin:4px 0 8px;"></p>

  <div class="results-table" style="width:100%;">
    <table>
      <thead>
        <tr>
          <th>Aqu√≠ s√≠</th>
          <th>Me da igual</th>
          <th>Pasando</th>
        </tr>
      </thead>
      <tbody id="results-body">
        <!-- Se rellena din√°micamente -->
      </tbody>
    </table>
  </div>

  <div style="margin-top:10px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap;">
    <button class="btn stats-btn" onclick="showStats()">Ver estad√≠sticas</button>
  </div>
</div>

<!-- Pantalla de estad√≠sticas -->
<div id="stats-screen" style="display:none;">
  <div class="stats-title-wrap">
    <h2>Estad√≠sticas globales</h2>
  </div>

  <!-- Parte superior: gr√°fico izquierda, top tarjetas derecha -->
  <div class="stats-grid">
    <div class="chart-card">
      <div class="chart-scroll">
        <canvas id="statsChart"></canvas>
      </div>
    </div>

    <div class="top-card">
      <h3 style="margin:4px 0 6px;">TOP tarjetas con m√°s "s√≠"</h3>
      <div class="top-scroll">
        <table id="topCardsTable">
          <thead><tr><th>Tarjeta</th><th>S√≠</th><th>Meh</th><th>No</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Parte inferior: afinidades -->
  <div class="affinity-wrap" id="affinityArea" style="display:none;">
    <div class="aff-card">
      <h3 style="margin:4px 0 6px;">Ranking de afinidad (todos los jugadores)</h3>
      <div class="aff-scroll">
        <table id="affinityGlobal">
          <thead><tr><th>Pareja</th><th>#</th><th>Tarjetas en com√∫n (S√ç)</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
    <div class="aff-card">
      <h3 style="margin:4px 0 6px;">Jugadores m√°s afines contigo</h3>
      <div class="aff-scroll">
        <table id="affinityPersonal">
          <thead><tr><th>Jugador</th><th>#</th><th>Tarjetas en com√∫n (S√ç)</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <div style="margin-top:8px; display:flex; justify-content:center;">
    <button class="btn reject" onclick="goToStart()">Volver</button>
  </div>
</div>

<script>
  /************ Config ************/
  const saveEndpoint = "/api/save"; // tu backend
  const dataUrl = "https://raw.githubusercontent.com/Syarapi/japotinder/main/results/data.json";

  /************ Datos base ************/
  const originalData = [
    { name: "Disney Tokyo", img: "img/disney.jpg" },
    { name: "Gotokuji", img: "img/gotokuji.jpg" },
    { name: "Pokemon Cafe", img: "img/pokemon.jpg" },
    { name: "Shikisai no oka", img: "img/shikisai.jpg" },
    { name: "Shinkansen Hello Kitty", img: "img/hello-kitty.jpg" },
    { name: "Maid cafe", img: "img/maid.jpg" },
    { name: "Nabana no sato", img: "img/nabana.jpg" },
    { name: "Otaru", img: "img/otaru.jpg" },
    { name: "Nagano y monos de nieve", img: "img/nagano.jpg" },
    { name: "RJ Cafe Osaka", img: "img/rj-cafe.jpg" },
    { name: "Kumachan Onsen Tokyo", img: "img/kumachan.jpg" },
    { name: "Enoshima", img: "img/enoshima.jpg" },
    { name: "Ginzan Onsen", img: "img/ginzan.jpg" },
    { name: "Tarde de recreativas", img: "img/arcade.jpg" },
    { name: "Shibazakura park Hokkaido", img: "img/shibazakura.jpg" },
    { name: "Musical Tokyo Revengers", img: "img/tokyo-revengers.jpg" },
    { name: "Eventos de mangas espec√≠ficos", img: "img/kisekoi.jpg" },
    { name: "Museo/cafe de los yokai", img: "img/yokai.jpg" },
    { name: "Kumamoto", img: "img/kumamoto.jpg" },
    { name: "Beppu", img: "img/beppu.jpg" },
    { name: "Bandai Museum", img: "img/bandai.jpg" },
    { name: "Tanuki Dori", img: "img/tanuki.jpg" },
    { name: "Coleccionar Manhole cards", img: "img/manhole.jpg" },
    { name: "Entrar a Sekaido o Itoya (90 pisos de material de arte)", img: "img/sekaido.jpg" },
    { name: "Doraemon time square", img: "img/doraemon.jpg" },
    { name: "Shiroi Koibito Park", img: "img/shiroi-koibito.jpg" },
    { name: "2D Caf√© Tokyo", img: "img/2dcafe.jpg" },
    { name: "Comer en Tofuro Ginza", img: "img/tofuro.jpg" },
    { name: "Music box Museum", img: "img/musicbox.jpg" },
    { name: "Aitama Daibutsu (Buddha y moais)", img: "img/aitama.jpg" },
    { name: "Hakone", img: "img/hakone.jpg" },
    { name: "Nikko", img: "img/nikko.jpg" },
    { name: "Oarai Isosaki shrine", img: "img/oarai.jpg" },
    { name: "Dormir en Ryokan Ookawaso", img: "img/ookawaso.jpg" },
    { name: "Museo de Nintendo", img: "img/nintendo.jpg" },
    { name: "Dormir en Onyado Nono Kyoto", img: "img/onyado.jpg" },
    { name: "Katsuouji y postal de Darumas", img: "img/katsuouji.jpg" },
    { name: "Dormir en Toggle (cada habitaci√≥n es de un √∫nico color completa)", img: "img/toggle.jpg" },
    { name: "Dormir en Henn na hotel", img: "img/hennna.jpg" },
    { name: "Probar los simulacros de terremotos", img: "img/terremoto.jpg" },
    { name: "Ir a ver sumo", img: "img/sumo.jpg" },
    { name: "Ir a ver kabuki", img: "img/kabuki.jpg" },
    { name: "Ushiku Daibutsu", img: "img/ushiku.jpg" },
    { name: "Tienda de Chopper", img: "img/mugiwara.jpg" },
  ];

  /************ Estado ************/
  let playerName = "";
  let mode = "short"; // "short" | "full"
  let data = [];
  let accepted = [];
  let rejected = [];
  let meh = [];
  let index = 0;
  let mehLimit = 5;
  let statsChartInstance = null;

  const container = document.getElementById('card-container');

  /************ Utilidades ************/
  const shuffleArray = (array) => array.slice().sort(() => Math.random() - 0.5);

  // Persistencia de colores √∫nicos por jugador
  const LS_KEY = "japotinder_player_colors_v3";
  function loadColorMap(){
    try{ return JSON.parse(localStorage.getItem(LS_KEY)) || {}; }catch{ return {}; }
  }
  function saveColorMap(map){ try{ localStorage.setItem(LS_KEY, JSON.stringify(map)); }catch{} }

  // Pool de colores legibles (combinan con la paleta)
  const COLOR_POOL = [
    "#2f7bdc", /* azul (reservado para Alba) */
    "#8a5adf", /* morado 1 (reservado Alicia) */
    "#b398d6", /* morado 2 (reservado Vaini) */
    "#acd68a",
    "#ff6fa1", /* rosa (reservado Sara) */
    "#48d1cc",
    "#ffd666", /* amarillo pastel legible */
    "#56e0b5", /* verde menta */
    "#68cba7",
    "#ffd8a3",
    "#ffccb1",
    "#c1ff71"
  ];

  // Conjuntos reservados √∫nicos
  const RESERVED = {
    "alba":   "#2f7bdc",
    "sara":   "#ff6fa1",
    "alicia": "#8a5adf",
    "vaini":  "#b398d6"
  };

  // Genera colores HSL legibles (fallback si se agota pool)
  function hslColor(i){
    const hue = (i * 47) % 360;
    return `hsl(${hue} 70% 55%)`;
  }

  // Asigna color √∫nico por nombre (persistente, sin colisiones con reservados ni entre s√≠)
  function getPlayerColorUnique(name){
    const key = (name||"").trim().toLowerCase();
    let map = loadColorMap();
    if (map[key]) return map[key];

    if (RESERVED[key]) {
      const reservedColor = RESERVED[key];
      for (const n in map) if (map[n] === reservedColor) delete map[n];
      map[key] = reservedColor; saveColorMap(map); return reservedColor;
    }

    const used = new Set(Object.values(map));
    Object.values(RESERVED).forEach(c=>used.add(c));

    for (const c of COLOR_POOL) {
      if (!used.has(c)) {
        map[key] = c; saveColorMap(map); return c;
      }
    }
    let i = 0;
    while(true){
      const c = hslColor(i++);
      if (!used.has(c)) { map[key] = c; saveColorMap(map); return c; }
    }
  }

  // Tema aleatorio (afecta fondos, bordes, acentos; NO los botones ni colores de series)
  function applyRandomTheme(){
  const themes = [
    { name:"sakura", light:"#fff7fb", mid:"#ffe3ef", dark:"#d38cb1", accent1:"#FF91C0", accent2:"#FF68A8", petal:[220,120,160] },
    { name:"sky",    light:"#f2f9ff", mid:"#e0f1ff", dark:"#8dbfe6", accent1:"#a3c9ff", accent2:"#7fb2f0", petal:[120,160,220] },
    { name:"lav",    light:"#faf5ff", mid:"#efe3ff", dark:"#b48ad6", accent1:"#d7a6f1", accent2:"#b48ad6", petal:[150,110,200] },
    { name:"sun",    light:"#fff7cc", mid:"#ffe89a", dark:"#e0c050", accent1:"#f0d46a", accent2:"#e1b84f", petal:[220,190,80] },
    { name:"mint",   light:"#e9fff8", mid:"#d1fff0", dark:"#68cba7", accent1:"#9fe6cc", accent2:"#68cba7", petal:[90,170,140] },

    // tus nuevos
    { name:"turq",   light:"#e0f7f5", mid:"#b2ebe7", dark:"#006c62", accent1:"#00b8a9", accent2:"#008b7e", petal:[0,180,169] },
    { name:"orange", light:"#fff1e6", mid:"#ffd1b3", dark:"#994d00", accent1:"#ff7a00", accent2:"#cc6300", petal:[255,122,0] },
    { name:"pastelr",light:"#ffeceb", mid:"#ffb3b0", dark:"#b94a48", accent1:"#f28b82", accent2:"#e57373", petal:[242,139,130] },
    { name:"coral",  light:"#ffd8cc", mid:"#ffb3a1", dark:"#ff6f61", accent1:"#ff9e80", accent2:"#ff6f61", petal:[255,159,128] },
    { name:"lilap",  light:"#f5f0ff", mid:"#e1d6f0", dark:"#9c86c3", accent1:"#b8a0d9", accent2:"#9c86c3", petal:[184,160,217] },
    { name:"melo",   light:"#fff0e6", mid:"#ffd1b3", dark:"#ffb07b", accent1:"#ffc49b", accent2:"#ffb07b", petal:[255,196,155] },
    { name:"aqua",   light:"#e6fbff", mid:"#b3edf5", dark:"#5ec2cc", accent1:"#8dd9e1", accent2:"#5ec2cc", petal:[141,217,225] },
    { name:"mintp",  light:"#e8fff5", mid:"#c6f5e0", dark:"#76c9aa", accent1:"#99e0c4", accent2:"#76c9aa", petal:[153,224,196] },
    { name:"rosep",  light:"#fff0f5", mid:"#ffd6e7", dark:"#e79aa8", accent1:"#f4b1c1", accent2:"#e79aa8", petal:[244,177,193] },
    { name:"butter", light:"#fffbe6", mid:"#fff2b3", dark:"#e6d465", accent1:"#f0e07f", accent2:"#e6d465", petal:[240,224,127] },
    { name:"lavp",   light:"#fdf5ff", mid:"#f5e1ff", dark:"#c89fd9", accent1:"#dcb6e7", accent2:"#c89fd9", petal:[220,182,231] }
  ];

  const pick = themes[Math.floor(Math.random()*themes.length)];
  const root = document.documentElement.style;

  root.setProperty('--bg-light', pick.light);
  root.setProperty('--bg-mid', pick.mid);
  root.setProperty('--bg-dark', pick.dark);
  root.setProperty('--accent-1', pick.accent1);
  root.setProperty('--accent-2', pick.accent2);

  // üõ°Ô∏è Fallback si falta petal
  const pet = Array.isArray(pick.petal) && pick.petal.length === 3
    ? pick.petal
    : [220,120,160]; // default "sakura"
  root.setProperty('--petal-rgba', `${pet[0]},${pet[1]},${pet[2]}`);

  // üîÅ tras cambiar de tema, repinta los kanji
  if (typeof spawnKanji === 'function') spawnKanji();
}


  function setPlayerInfo(dateTime){
    const spanColor = getPlayerColorUnique(playerName);
    const html = `Jugador: <span style="font-weight:700; color:${spanColor}">${playerName}</span> | ${dateTime} | Modo: ${mode === 'short' ? 'Corto' : 'Completo'}`;
    document.getElementById('player-info').innerHTML = html;
  }

  // Lectura robusta de data.json
  function ensureArray(maybeArray) {
    if (Array.isArray(maybeArray)) return maybeArray;
    if (maybeArray && Array.isArray(maybeArray.games)) return maybeArray.games;
    return [];
  }
  
  // Tarjetas ya vistas por un jugador (toma la √öLTIMA decisi√≥n por tarjeta)
async function getSeenCardsForPlayer(name){
  const seen = new Set();
  try {
    const res = await fetch(`${dataUrl}?t=${Date.now()}`);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const games = ensureArray(await res.json());

    // deduplicar por √∫ltima respuesta del jugador
    const latest = new Map(); // card -> ts
    games
      .filter(g => g && g.player && g.player.trim().toLowerCase() === name.trim().toLowerCase())
      .forEach(g => {
        const ts = Date.parse(g.date || g.timestamp || "") || 0;
        const add = (card) => {
          const prev = latest.get(card);
          if (!prev || ts >= prev) latest.set(card, ts);
        };
        (g.accepted||[]).forEach(add);
        (g.meh||[]).forEach(add);
        (g.rejected||[]).forEach(add);
      });

    latest.forEach((_ts, card)=>seen.add(card));
  } catch(e){
    // si falla la red, simplemente no filtramos
    console.warn("No se pudo cargar partidas previas para filtrar:", e);
  }
  return seen;
}


  /************ Flujo UI ************/
  document.getElementById("btnNameNext").addEventListener("click", () => {
    const nameInput = document.getElementById("username").value.trim();
    if (!nameInput) { alert("Que me digas qui√©n eres o no jugamos √π3√∫"); return; }
    playerName = nameInput;
    document.getElementById("start-screen").style.display = "none";
    document.getElementById("mode-screen").style.display = "flex";
  });

  // Mitades clicables (modo)
  document.getElementById("halfShort").addEventListener("click", () => {
    mode = "short"; mehLimit = 5; startGameWithMode();
  });
  document.getElementById("halfFull").addEventListener("click", () => {
    mode = "full"; mehLimit = 10; startGameWithMode();
  });

  function startGameWithMode() {
    let safeOriginal = [...originalData];
    const SHORT_COUNT = 20; // ajusta aqu√≠ si quieres otro valor fijo

    if (mode === "short") {
        // 1Ô∏è‚É£ Historial de cartas jugadas por este jugador
        const pastCards = new Set();
        const safeGames = ensureArray(loadData("games"));
        safeGames
            .filter(g => g.player === playerName)
            .forEach(g => {
                [...g.accepted, ...g.meh, ...g.rejected].forEach(card => pastCards.add(card));
            });

        // 2Ô∏è‚É£ Filtrar cartas nuevas
        let availableCards = safeOriginal.filter(c => !pastCards.has(c.name));

        // 3Ô∏è‚É£ Si no hay suficientes nuevas, se mezclan todas
        if (availableCards.length < SHORT_COUNT) {
            availableCards = shuffleArray([...safeOriginal]);
        } else {
            availableCards = shuffleArray(availableCards);
        }

        data = availableCards.slice(0, Math.min(SHORT_COUNT, availableCards.length));
    } else {
        data = shuffleArray(safeOriginal);
    }

    index = 0;
    accepted = [];
    rejected = [];
    meh = [];

    container.innerHTML = "";
    document.getElementById("mode-screen").style.display = "none";
    document.getElementById("game-screen").style.display = "flex";
    showNextCard(true);
}


  function restartGame() {
    document.getElementById("results").style.display = "none";
    document.getElementById("start-screen").style.display = "flex";
  }
  function goToStart() {
    document.getElementById("stats-screen").style.display = "none";
    document.getElementById("start-screen").style.display = "flex";
  }

  /************ Tarjetas + Swipe ************/
  function createCard(item) {
    const card = document.createElement('div'); card.className = 'card';
    const img = document.createElement('img'); img.src = item.img; img.alt = item.name;
    const name = document.createElement('div'); name.textContent = item.name;
    card.appendChild(img); card.appendChild(name);
    attachSwipe(card);
    return card;
  }

  function showNextCard(initial=false) {
    if (!initial) container.innerHTML = "";
    if (index < data.length) {
      const card = createCard(data[index]);
      container.appendChild(card);
    } else {
      showResults();
    }
  }

  // Swipe (izquierda=-1, derecha=1, arriba=0)
  function attachSwipe(el){
    let startX=0, startY=0, dx=0, dy=0, active=false;

    const onStart = (x,y) => { active=true; startX=x; startY=y; dx=0; dy=0; el.style.transition=""; };
    const onMove = (x,y) => {
      if(!active) return;
      dx = x - startX; dy = y - startY;
      const rot = dx * 0.05;
      el.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg)`;
      el.style.opacity = String(1 - Math.min(0.6, Math.abs(dx)/300 + Math.max(0, -dy)/300));
    };
    const onEnd = () => {
      if(!active) return;
      active=false;
      const THX = 80, THY = -80; // arriba es negativo
      if (dx <= -THX) { commitDecision(-1, el); return; }   // izquierda -> no
      if (dx >=  THX) { commitDecision( 1, el); return; }   // derecha  -> s√≠
      if (dy <=  THY) { commitDecision( 0, el); return; }   // arriba   -> meh
      el.style.transition="transform .2s ease, opacity .2s ease";
      el.style.transform="translate(0,0) rotate(0)";
      el.style.opacity="1";
    };

    // Touch
    el.addEventListener("touchstart", (e)=>onStart(e.touches[0].clientX, e.touches[0].clientY), {passive:true});
    el.addEventListener("touchmove",  (e)=>onMove(e.touches[0].clientX, e.touches[0].clientY), {passive:true});
    el.addEventListener("touchend",   onEnd);

    // Mouse
    el.addEventListener("mousedown", (e)=>onStart(e.clientX, e.clientY));
    window.addEventListener("mousemove", (e)=>onMove(e.clientX, e.clientY));
    window.addEventListener("mouseup", onEnd);
  }

  function commitDecision(direction, el){
    const name = el.querySelector('div').textContent;
    if (direction === 1) accepted.push(name);
    else if (direction === -1) rejected.push(name);
    else {
      if (meh.length >= mehLimit) {
        alert("Por favor, m√≥jate un poco m√°s‚Ä¶");
        el.style.transition="transform .2s ease, opacity .2s ease";
        el.style.transform="translate(0,0) rotate(0)";
        el.style.opacity="1";
        return;
      }
      meh.push(name);
    }
    index++;
    container.innerHTML = "";
    showNextCard();
  }

  function handleDecision(direction){
    const el = container.querySelector('.card');
    if (!el) return;
    commitDecision(direction, el);
  }

  /************ Resultados + Guardado ************/
  function buildResultsTableRows(a, m, r){
    // Calcula m√°ximo de filas para alinear columnas
    const maxRows = Math.max(a.length, m.length, r.length);
    const rows = [];
    for (let i=0;i<maxRows;i++){
      rows.push(`
        <tr>
          <td>${a[i] ? a[i] : ""}</td>
          <td>${m[i] ? m[i] : ""}</td>
          <td>${r[i] ? r[i] : ""}</td>
        </tr>
      `);
    }
    return rows.join("");
  }

  async function showResults() {
    document.getElementById('game-screen').style.display = 'none';
    document.getElementById('results').style.display = 'flex';
    const now = new Date(); const dateTime = now.toLocaleString();
    setPlayerInfo(dateTime);

    // Rellenar tabla √∫nica
    const tbody = document.getElementById('results-body');
    tbody.innerHTML = buildResultsTableRows(accepted, meh, rejected);

    try {
      await fetch(saveEndpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ player: playerName, date: dateTime, mode, accepted, meh, rejected })
      });
    } catch (e) {
      console.warn("No se pudo guardar en la API:", e);
    }
  }

/************ Estad√≠sticas ************/
async function showStats() {
  // Mostrar contenedor stats y limpiar anteriores
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('mode-screen').style.display = 'none';
  document.getElementById('results').style.display = 'none';
  document.getElementById('stats-screen').style.display = 'block';

  const topBody = document.querySelector('#topCardsTable tbody');
  const gBody   = document.querySelector('#affinityGlobal tbody');
  const pBody   = document.querySelector('#affinityPersonal tbody');

  topBody.innerHTML = "";
  gBody.innerHTML   = "";
  pBody.innerHTML   = "";
  document.getElementById('affinityArea').style.display = "none";

  // Cargar datos
  let games = [];
  try {
    const res = await fetch(`${dataUrl}?t=${Date.now()}`);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const json = await res.json();
    games = ensureArray(json);
  } catch (err) {
    alert("No se pudo cargar results/data.json: " + err.message);
    destroyChart();
    return;
  }
  if (!games.length) { destroyChart(); return; }

  // Normalizar juego
  const safeGames = games
    .filter(g => g && (Array.isArray(g.accepted) || Array.isArray(g.rejected) || Array.isArray(g.meh)))
    .map(g => ({
      player: (g.player || "¬øanon?").trim(),
      accepted: Array.isArray(g.accepted) ? g.accepted : [],
      meh: Array.isArray(g.meh) ? g.meh : [],
      rejected: Array.isArray(g.rejected) ? g.rejected : [],
      ts: Date.parse(g.date || g.timestamp || "") || 0
    }));

  // 1 voto m√°ximo por jugador y tarjeta
  const latest = {};
  for (const g of safeGames) {
    const p = g.player;
    if (!latest[p]) latest[p] = {};
    const up = (card, choice) => {
      const prev = latest[p][card];
      if (!prev || g.ts >= prev.ts) latest[p][card] = { choice, ts: g.ts };
    };
    g.accepted.forEach(c => up(c, 'yes'));
    g.meh.forEach(c      => up(c, 'meh'));
    g.rejected.forEach(c => up(c, 'no'));
  }

  // Conteos por tarjeta
  const stats = {};
  for (const p in latest) {
    for (const card in latest[p]) {
      const ch = latest[p][card].choice;
      if (!stats[card]) stats[card] = { yes:0, meh:0, no:0 };
      stats[card][ch] += 1;
    }
  }

  // Gr√°fico apilado
  const labels  = Object.keys(stats).sort((a,b)=>a.localeCompare(b));
  const yesData = labels.map(l => stats[l].yes);
  const mehData = labels.map(l => stats[l].meh);
  const noData  = labels.map(l => stats[l].no);

  const canvas = document.getElementById('statsChart');
  const desiredWidth = Math.max(labels.length * 42, 420);
  canvas.width = desiredWidth;
  canvas.height = 320;
  const ctx = canvas.getContext('2d');

  const css = getComputedStyle(document.documentElement);
  const grad = (hex) => {
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0,hex);
    g.addColorStop(1,hex);
    return g;
  };

  destroyChart();
  if (typeof Chart === 'function') {
    statsChartInstance = new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [
          { label: 'Aqu√≠ s√≠',     data: yesData, backgroundColor: grad(css.getPropertyValue('--yes').trim()), borderRadius: 8, stack: 'stack' },
          { label: 'Me da igual', data: mehData, backgroundColor: grad(css.getPropertyValue('--meh').trim()), borderRadius: 8, stack: 'stack' },
          { label: 'Pasando',     data: noData,  backgroundColor: grad(css.getPropertyValue('--no').trim()),  borderRadius: 8, stack: 'stack' }
        ]
      },
      options: {
        responsive: false, maintainAspectRatio: false,
        scales: { x: { stacked: true, ticks: { maxRotation: 60, minRotation: 0 } }, y: { stacked: true, beginAtZero: true } },
        plugins: {
          legend: { labels: { color: '#333', boxWidth: 18, usePointStyle: true, pointStyle: 'rectRounded' } },
          tooltip: { backgroundColor: 'rgba(255,255,255,.95)', titleColor: '#333', bodyColor: '#333', borderColor: '#ddd', borderWidth: 1 }
        },
        animation: { duration: 220 }
      }
    });
  }

  // TOP tarjetas
  const topCards = Object.entries(stats)
    .sort((a,b) => b[1].yes - a[1].yes || a[0].localeCompare(b[0]));
  for (const [name, v] of topCards) {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${name}</td><td>${v.yes}</td><td>${v.meh}</td><td>${v.no}</td>`;
    topBody.appendChild(tr);
  }

  // Afinidad (S√ç) por jugador
  const byPlayer = {};
  for (const p in latest) {
    const set = new Set();
    for (const card in latest[p]) {
      if (latest[p][card].choice === 'yes') set.add(card);
    }
    if (set.size) byPlayer[p] = set;
  }

  const players = Object.keys(byPlayer).sort((a,b)=>a.localeCompare(b));

  // Ranking global de parejas
  const pairs = [];
  for (let i=0;i<players.length;i++){
    for (let j=i+1;j<players.length;j++){
      const p1 = players[i], p2 = players[j];
      const s1 = byPlayer[p1], s2 = byPlayer[p2];
      const inter = [];
      s1.forEach(x => { if (s2.has(x)) inter.push(x); });
      if (inter.length) pairs.push({ a:p1, b:p2, common:inter.sort(), count:inter.length });
    }
  }
  pairs.sort((x,y)=> y.count - x.count || (x.a+x.b).localeCompare(y.a+y.b));

  // Render afinidad global
  pairs.slice(0, 200).forEach(row=>{
    const cA = getPlayerColorUnique(row.a);
    const cB = getPlayerColorUnique(row.b);
    const tr = document.createElement('tr');
    tr.innerHTML =
      `<td><span style="font-weight:600;color:${cA}">${row.a}</span> &amp; ` +
      `<span style="font-weight:600;color:${cB}">${row.b}</span></td>` +
      `<td>${row.count}</td>` +
      `<td class="cards-small">${row.common.join(", ")}</td>`;
    gBody.appendChild(tr);
  });

  // Afinidad personal
  let personalRows = [];
  if (playerName && byPlayer[playerName]) {
    const mine = byPlayer[playerName];
    players.filter(p=>p!==playerName).forEach(p=>{
      const inter = [];
      byPlayer[p].forEach(x=>{ if (mine.has(x)) inter.push(x); });
      if (inter.length) personalRows.push({ player:p, count:inter.length, list:inter.sort() });
    });
    personalRows.sort((x,y)=> y.count - x.count || x.player.localeCompare(y.player));
  }

  if (personalRows.length){
    personalRows.slice(0,200).forEach(r=>{
      const c = getPlayerColorUnique(r.player);
      const tr = document.createElement('tr');
      tr.innerHTML = `<td style="font-weight:600; color:${c}">${r.player}</td><td>${r.count}</td><td class="cards-small">${r.list.join(", ")}</td>`;
      pBody.appendChild(tr);
    });
  } else {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td colspan="3"><span class="notice">Juega una partida para ver tu afinidad personal.</span></td>`;
    pBody.appendChild(tr);
  }

  // Mostrar bloque inferior
  document.getElementById('affinityArea').style.display = "grid";
}

  /* === Generador de kanji cayendo (reemplaza a los p√©talos) === */
function initKanjiRain(){
  // Conjunto de kanji para elegir al azar (puedes ampliar la lista)
  const KANJI = "Êó•ÊúàÁÅ´Ê∞¥Êú®ÈáëÂúüÂ±±Â∑ùÁî∞‰∫∫Âè£Â•≥Â≠êÂ≠¶Ê†°ÂÖàÁîüÊôÇÈñìÊù±‰∫¨Êó•Êú¨Â§ß‰∏≠Â∞è‰∏ä‰∏ãÂ∑¶Âè≥ÂÖ•Âè£Âá∫Âè£ÈßÖËªäÈõªÊ∞óÈ£üÈ£≤Ë¶ãË°åÊù•‰ºöË©±Ë™≠Êõ∏Êò†ÁîªÈü≥Ê•ΩËä±ÊÑõÂèãÂπ∏Ê•ΩÊµ∑Á©∫È¢®Èõ®Èõ™Áå´Áä¨È≥•ÈæçÂøÉÊòüÊò•Â§èÁßãÂÜ¨Â§¢ÈÅìÁ•ûÂØ∫Á§æÊ°úÂÖâÁæéÂíåÊñ∞Âè§ÊóÖÈ£üË≤∑È£≤ÈÅäË™ûÂ≠¶ÂÜôÁúü";
  const pick = () => KANJI[Math.floor(Math.random() * KANJI.length)];

  // Cantidad por capa (ajusta si quieres m√°s/menos densidad)
  const COUNT_A = 40; // capa r√°pida (24s)
  const COUNT_B = 40; // capa lenta  (32s)

  const makeChar = (layerClass) => {
    const el = document.createElement('span');
    el.className = `kanji-char ${layerClass}`;
    el.textContent = pick();

    // Aleatoriedad de posici√≥n/tama√±o/rotaci√≥n y fase
    const vw = Math.random() * 100;                // posici√≥n horizontal
    const size = 14 + Math.random() * 18;          // 14px ~ 32px
    const rot = (Math.random() * 60 - 30) + "deg"; // -30deg ~ 30deg
    const delay = (-Math.random() * 32).toFixed(2) + "s"; // arranque desfasado
    const drift = (Math.random() * 60 - 30) + "px";       // leve deriva base

    el.style.setProperty('--x', vw + 'vw');
    el.style.setProperty('--r', rot);
    el.style.fontSize = size + 'px';
    el.style.animationDelay = delay;

    // Peque√±a variaci√≥n extra entre caracteres
    el.style.transform = `translateX(${drift}) translateY(-12vh) rotate(${rot})`;

    document.body.appendChild(el);
  };

  for (let i = 0; i < COUNT_A; i++) makeChar('kanji-layer-a');
  for (let i = 0; i < COUNT_B; i++) makeChar('kanji-layer-b');
}


  /************ Init ************/
  applyRandomTheme();
  initKanjiRain(); 
  document.getElementById("start-screen").style.display = "flex";
</script>
</body>
</html>


















